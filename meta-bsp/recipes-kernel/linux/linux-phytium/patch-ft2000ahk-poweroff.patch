diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index d6a49bb07..19df624c9 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -49,6 +49,7 @@
 #include <trace/events/power.h>
 #include <linux/percpu.h>
 #include <linux/thread_info.h>
+#include <linux/delay.h>
 
 #include <asm/alternative.h>
 #include <asm/compat.h>
@@ -65,13 +66,96 @@ unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);
 #endif
 
+#define GPIO_BASE       0x70006000
+#define GPIO_SEL_BASE   0x70100000
+#define GPIO_SEL_0      0x70100c0c
+
+static void reset_cpu(enum reboot_mode reboot_mode, const char *cmd)
+{
+	unsigned int val;
+	unsigned int mask = 0x3c0;
+
+	void __iomem *gpio_base;
+	void __iomem *gpio_sel_0;
+
+	gpio_base = ioremap(GPIO_BASE, 8);
+	gpio_sel_0 = ioremap(GPIO_SEL_0, 4);
+
+	if (!gpio_base || !gpio_sel_0) {
+		printk("ioremap failed!\n");
+		return;
+	}
+
+	/* select gpio A4, A3, gpio func */
+	val = readl(gpio_sel_0);
+	val = val & (~mask);
+	val = val | (0x1 << 8) | (0x1 << 6);
+	writel(val, gpio_sel_0);
+
+	/* set gpio A4, A3 output */
+	val = readl(gpio_base + 0x4);
+	writel(val | 0x3 << 3, gpio_base + 0x4);
+
+	/* A4, A3 output 0 */
+	val = readl(gpio_base);
+	val = val & (~(0x3 << 3));
+	writel(val, gpio_base);
+
+	/* delay 10ms */
+	udelay(10000);
+
+	/* D3 output 1 */
+	val = readl(gpio_base);
+	writel(val | (0x1 << 3), gpio_base);
+}
+
+static void shutdown_cpu(void)
+{
+	unsigned int val;
+	unsigned int mask = 0x3c0;
+	void __iomem *gpio_base;
+	void __iomem *gpio_sel_0;
+
+	gpio_base = ioremap(GPIO_BASE, 8);
+	gpio_sel_0 = ioremap(GPIO_SEL_0, 4);
+
+	 if (!gpio_base || !gpio_sel_0) {
+		 printk("ioremap failed!\n");
+		 return;
+	 }
+
+	/* select gpio A4, A3, gpio func */
+	val = readl(gpio_sel_0);
+	val = val & (~mask);
+	val = val | (0x1 << 8) | (0x1 << 6);
+	writel(val, gpio_sel_0);
+
+	/* set gpio A4, A3 output */
+	val = readl(gpio_base + 0x4);
+	writel(val | 0x3 << 3, gpio_base + 0x4);
+
+	/* D4, D3 output 0 */
+	val = readl(gpio_base);
+	val = val & (~(0x3 << 3));
+	writel(val, gpio_base);
+
+	/* delay 10ms */
+	udelay(10000);
+
+	/* D4 output 1 */
+	val = readl(gpio_base);
+	writel(val | (0x1 << 4), gpio_base);
+}
+
 /*
  * Function pointers to optional machine specific functions
  */
-void (*pm_power_off)(void);
+void (*pm_power_off)(void) = shutdown_cpu;
 EXPORT_SYMBOL_GPL(pm_power_off);
 
-void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
+void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd) = reset_cpu;
+EXPORT_SYMBOL(arm_pm_restart);
+
 
 /*
  * This is our default idle handler.
